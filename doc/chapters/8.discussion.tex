\section{Discussion} We now discuss our main findings, how RxFiddle
resolves the debugging problem of Rx, and contrast our design to other
design choices and possibilities of future work.

\subsection{Main results}
\paragraph{Quick and dirty debugging} Through interviews and literature
we establish that current debugging practices for RP consist mostly of
\printfdebugging{}.  The shortcomings of this method were evident from
the interviews:  it works reliably only for synchronous execution or
small amounts of events being logged, otherwise overview is lost.
Furthermore the time-context of events and dependency-context of flows
are not available using this method.  We attribute the prevalence of
\printfdebugging{} to this \emph{``quick and dirty''} method being
available in every language and on every platform, without a viable
alternative.

\paragraph{Improved context:  being complete, disposing doubts} With our
design and complementary implementation we show that the abstract model
of RP is suitable for visualization on two levels:  overview and detail.
On the overview level, we complement the dependencies visible in source
code with a graph of the resulting structure, showing the run-time
effect of certain operators on the reactive structure.  On the detail
level we add the time-context, by showing previous values on a
horizontal time line, and the dependency-context, by showing input and
output flows above and below the flow of interest.  While the results of
our evaluation could be observed as a negative, RxFiddle is a new tool,
where subjects have only just been exposed to the tool and received only
a short training.  We expect that by designing a debugger model so close
to the actual abstractions, our debugger works especially well for users
with some knowledge of these abstractions; while only T3 shows better
performance with high significancy, we observe slightly better results
when controlling for experience.  Future research might investigate the
effect of experience in more detail, including the use of more
complicated tasks, with larger samples.

In the presented research, we did not perform tests with subjects using
their own code.  However, during piloting and after the release of
RxFiddle we received positive feedback regarding the completeness of the
visualization.  As one user put it, \emph{``by using RxFiddle when
learning and understanding what RxJS does in our project, I have a
feeling of improved control over our Observables, Subscriptions and the
reactive parts of our app''}.  Specifically the life-cycle events, which
are generally hard to debug using \printfdebugging{}, are more clear:
\emph{``Initially we were reluctant to manually subscribe, but after
seeing that `complete' often triggers a `dispose', the team became more
confident to sometimes use \code{subscribe()} directly''}.  Future
research might address this by designing experiments specifically using
the users own code.

%%%%%%%%%%%%%%%%
% Quotes:
% ``the experience helped me understand what a specific operator was doing and how it was messing up my code.''
% `` Dat was de ervaring die ik net beschreef en die kwam direct voort uit wat wij keer hadden besproken dat `.share()` iets complexer is dan dat wij (als team) hadden gedacht en dat de effecten van hem twee keer gebruiken nogal, ongewenst waren. Dat hadden we op geen manier kunnen debuggen zonder RxFiddle, want met een `console.log()` kan je dat niet checken''.
% ``Wij waren vroeg in het project een beetje huiverig voor `subscribe()` en door RxFiddle zagen we dat een `onComplete()` ook een `unsubscribe()` triggert, in veel gevallen. En dat maakte het team iets geruster om hier en daar een `subscribe()` te gebruiken.''
% ``Door mâ€™n ervaringen met onder andere RxFiddle ten tijde van het leren en begrijpen van wat RxJS in ons project doet, heb ik het idee nu meer grip te hebben op onze Observables, Subscriptions en de Reactive delen van onze applicatie.''

%%%%%%%%%%%%%%%%% OLD
